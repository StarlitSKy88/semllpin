/**\n * SmellPin æµ‹è¯•æ•°æ®å·¥å‚ - Phase 2 \n * å¯é‡å¤éšæœºç§å­ + ç”Ÿäº§çº§æ•°æ®ç”Ÿæˆ\n * æ”¯æŒåœ°ç†çƒ­åŒºæ•°æ® + ä¸šåŠ¡çœŸå®åœºæ™¯\n */\nimport { faker } from '@faker-js/faker';\nimport { testUtils } from '../setup/jest-setup';\n\n// è®¾ç½®å¯é‡å¤çš„éšæœºç§å­\nfaker.seed(42);\n\n// çœŸå®çš„åŒ—äº¬åœ°ç†çƒ­åŒºæ•°æ®\nconst BEIJING_HOTSPOTS = [\n  { name: 'ä¸‰é‡Œå±¯', lat: 39.9369, lng: 116.4462, category: 'commercial' },\n  { name: 'ä¸­å…³æ‘', lat: 39.9788, lng: 116.3014, category: 'tech' },\n  { name: 'å›½è´¸CBD', lat: 39.9090, lng: 116.4587, category: 'business' },\n  { name: 'æ•…å®«', lat: 39.9163, lng: 116.3972, category: 'tourist' },\n  { name: 'å¤©å›', lat: 39.8812, lng: 116.4068, category: 'tourist' },\n  { name: 'äº¦åº„', lat: 39.7987, lng: 116.5267, category: 'industrial' },\n  { name: 'æœ›äº¬', lat: 39.9963, lng: 116.4723, category: 'residential' },\n  { name: 'è¥¿å•', lat: 39.9069, lng: 116.3760, category: 'commercial' }\n];\n\n// æ°”å‘³ç±»å‹çœŸå®æ•°æ®\nconst SMELL_CATEGORIES = {\n  industrial: {\n    types: ['chemical', 'paint', 'plastic', 'metal', 'rubber'],\n    intensities: [6, 7, 8, 9, 10],\n    descriptions: ['åˆºé¼»çš„åŒ–å­¦æ°”å‘³', 'æµ“çƒˆçš„æ²¹æ¼†å‘³', 'å¡‘æ–™ç‡ƒçƒ§å‘³', 'é‡‘å±åŠ å·¥å¼‚å‘³']\n  },\n  sewage: {\n    types: ['sewer', 'waste', 'drainage'],\n    intensities: [4, 5, 6, 7, 8],\n    descriptions: ['ä¸‹æ°´é“è‡­å‘³', 'æ±¡æ°´å¤„ç†å¼‚å‘³', 'æ’æ°´ç®¡é“æ°”å‘³']\n  },\n  garbage: {\n    types: ['rotting', 'organic', 'compost'],\n    intensities: [3, 4, 5, 6, 7],\n    descriptions: ['è…çƒ‚åƒåœ¾å‘³', 'æœ‰æœºç‰©å‘é…µå‘³', 'å †è‚¥å‘é…µæ°”å‘³']\n  },\n  food: {\n    types: ['cooking', 'frying', 'fermentation'],\n    intensities: [2, 3, 4, 5],\n    descriptions: ['æ²¹çƒŸå‘³', 'ç…ç‚¸é£Ÿç‰©æ°”å‘³', 'å‘é…µé£Ÿå“å‘³']\n  }\n};\n\n// ç”¨æˆ·è¡Œä¸ºæ¨¡å¼æ•°æ®\nconst USER_PATTERNS = {\n  NewUser: {\n    sessionDuration: { min: 5, max: 15 }, // åˆ†é’Ÿ\n    actionsPerSession: { min: 3, max: 8 },\n    errorProbability: 0.15,\n    helpSeekingProbability: 0.3\n  },\n  ActiveUser: {\n    sessionDuration: { min: 10, max: 30 },\n    actionsPerSession: { min: 8, max: 20 },\n    errorProbability: 0.05,\n    helpSeekingProbability: 0.1\n  },\n  PowerUser: {\n    sessionDuration: { min: 20, max: 60 },\n    actionsPerSession: { min: 15, max: 40 },\n    errorProbability: 0.02,\n    helpSeekingProbability: 0.05\n  },\n  MobileUser: {\n    sessionDuration: { min: 3, max: 12 },\n    actionsPerSession: { min: 2, max: 10 },\n    errorProbability: 0.08,\n    locationChangeProbability: 0.7\n  },\n  StressUser: {\n    sessionDuration: { min: 1, max: 3 },\n    actionsPerSession: { min: 10, max: 100 },\n    errorProbability: 0.3,\n    maliciousProbability: 0.1\n  }\n};\n\n/**\n * ç”¨æˆ·æ•°æ®å·¥å‚\n */\nexport class UserFactory {\n  static create(overrides: Partial<any> = {}) {\n    const baseUser = {\n      id: faker.string.uuid(),\n      username: faker.internet.userName(),\n      email: faker.internet.email(),\n      password: faker.internet.password({ length: 12 }),\n      nickname: faker.person.fullName(),\n      avatar: faker.image.avatar(),\n      phoneNumber: faker.phone.number('13#########'),\n      location: testUtils.generateBeijingCoordinate(),\n      isVerified: faker.datatype.boolean({ probability: 0.7 }),\n      level: faker.helpers.arrayElement([1, 2, 3, 4, 5]),\n      points: faker.number.int({ min: 0, max: 10000 }),\n      joinedAt: faker.date.past({ years: 2 }),\n      lastActiveAt: faker.date.recent({ days: 7 }),\n      preferences: {\n        notifications: faker.datatype.boolean({ probability: 0.8 }),\n        privacyLevel: faker.helpers.arrayElement(['public', 'friends', 'private']),\n        language: faker.helpers.arrayElement(['zh-CN', 'en-US'])\n      },\n      stats: {\n        annotationsCreated: faker.number.int({ min: 0, max: 100 }),\n        likesReceived: faker.number.int({ min: 0, max: 500 }),\n        commentsReceived: faker.number.int({ min: 0, max: 200 })\n      }\n    };\n\n    return { ...baseUser, ...overrides };\n  }\n\n  static createBatch(count: number, overrides: Partial<any> = {}) {\n    return Array.from({ length: count }, () => this.create(overrides));\n  }\n\n  static createByType(userType: keyof typeof USER_PATTERNS, overrides: Partial<any> = {}) {\n    const pattern = USER_PATTERNS[userType];\n    const typeSpecificData = {\n      userType,\n      sessionPattern: pattern,\n      // æ ¹æ®ç”¨æˆ·ç±»å‹è°ƒæ•´å±æ€§\n      level: userType === 'NewUser' ? 1 : \n             userType === 'PowerUser' ? faker.number.int({ min: 4, max: 5 }) : \n             faker.number.int({ min: 2, max: 4 }),\n      isVerified: userType === 'StressUser' ? false : faker.datatype.boolean({ probability: 0.8 })\n    };\n\n    return this.create({ ...typeSpecificData, ...overrides });\n  }\n}\n\n/**\n * æ ‡æ³¨æ•°æ®å·¥å‚\n */\nexport class AnnotationFactory {\n  static create(overrides: Partial<any> = {}) {\n    // éšæœºé€‰æ‹©ä¸€ä¸ªçƒ­åŒº\n    const hotspot = faker.helpers.arrayElement(BEIJING_HOTSPOTS);\n    const category = faker.helpers.arrayElement(Object.keys(SMELL_CATEGORIES));\n    const smellData = SMELL_CATEGORIES[category as keyof typeof SMELL_CATEGORIES];\n    \n    // åœ¨çƒ­åŒºé™„è¿‘ç”Ÿæˆä½ç½®ï¼ˆ500ç±³èŒƒå›´å†…ï¼‰\n    const location = {\n      lat: hotspot.lat + faker.number.float({ min: -0.005, max: 0.005 }),\n      lng: hotspot.lng + faker.number.float({ min: -0.005, max: 0.005 })\n    };\n\n    const baseAnnotation = {\n      id: faker.string.uuid(),\n      title: faker.lorem.sentence({ min: 3, max: 8 }),\n      description: faker.helpers.arrayElement(smellData.descriptions) + 'ã€‚' + faker.lorem.sentences(2),\n      location,\n      category,\n      smellType: faker.helpers.arrayElement(smellData.types),\n      intensity: faker.helpers.arrayElement(smellData.intensities),\n      tags: faker.helpers.arrayElements(\n        ['å¼‚å‘³', 'æ±¡æŸ“', 'ç¯å¢ƒ', 'ä¸¾æŠ¥', 'ç›‘æµ‹', hotspot.name],\n        { min: 2, max: 4 }\n      ),\n      userId: faker.string.uuid(),\n      media: faker.datatype.boolean({ probability: 0.6 }) ? [\n        {\n          id: faker.string.uuid(),\n          type: 'image',\n          url: faker.image.url({ width: 800, height: 600 }),\n          thumbnailUrl: faker.image.url({ width: 200, height: 150 })\n        }\n      ] : [],\n      status: faker.helpers.arrayElement(['active', 'verified', 'flagged', 'resolved']),\n      visibility: faker.helpers.arrayElement(['public', 'friends', 'private']),\n      likesCount: faker.number.int({ min: 0, max: 100 }),\n      commentsCount: faker.number.int({ min: 0, max: 50 }),\n      reportsCount: faker.number.int({ min: 0, max: 5 }),\n      createdAt: faker.date.recent({ days: 30 }),\n      updatedAt: faker.date.recent({ days: 7 }),\n      expiresAt: faker.date.future({ years: 1 }),\n      // PostGIS ç›¸å…³å­—æ®µ\n      geohash: generateGeoHash(location.lat, location.lng),\n      nearbyHotspot: hotspot.name,\n      distanceFromCenter: calculateDistanceFromCenter(location)\n    };\n\n    return { ...baseAnnotation, ...overrides };\n  }\n\n  static createBatch(count: number, overrides: Partial<any> = {}) {\n    return Array.from({ length: count }, () => this.create(overrides));\n  }\n\n  static createForHotspot(hotspotName: string, count: number = 1) {\n    const hotspot = BEIJING_HOTSPOTS.find(h => h.name === hotspotName);\n    if (!hotspot) throw new Error(`Unknown hotspot: ${hotspotName}`);\n\n    return this.createBatch(count, {\n      location: {\n        lat: hotspot.lat + faker.number.float({ min: -0.002, max: 0.002 }),\n        lng: hotspot.lng + faker.number.float({ min: -0.002, max: 0.002 })\n      },\n      nearbyHotspot: hotspot.name\n    });\n  }\n}\n\n/**\n * æ”¯ä»˜æ•°æ®å·¥å‚\n */\nexport class PaymentFactory {\n  static create(overrides: Partial<any> = {}) {\n    const paymentMethods = ['alipay', 'wechat', 'stripe', 'paypal'];\n    const currencies = ['CNY', 'USD'];\n    const statuses = ['pending', 'processing', 'completed', 'failed', 'refunded'];\n\n    const basePayment = {\n      id: faker.string.uuid(),\n      userId: faker.string.uuid(),\n      annotationId: faker.string.uuid(),\n      amount: faker.number.int({ min: 100, max: 5000 }), // åˆ†ä¸ºå•ä½\n      currency: faker.helpers.arrayElement(currencies),\n      method: faker.helpers.arrayElement(paymentMethods),\n      status: faker.helpers.arrayElement(statuses),\n      transactionId: faker.string.alphanumeric(20),\n      platformTransactionId: `${faker.helpers.arrayElement(['pi_', 'ch_', 'tr_'])}${faker.string.alphanumeric(24)}`,\n      description: 'æ ‡æ³¨è´¹ç”¨æ”¯ä»˜',\n      metadata: {\n        annotationType: faker.helpers.arrayElement(['basic', 'premium', 'emergency']),\n        userLevel: faker.number.int({ min: 1, max: 5 }),\n        discount: faker.datatype.boolean({ probability: 0.2 }) ? faker.number.float({ min: 0.1, max: 0.3 }) : 0\n      },\n      createdAt: faker.date.recent({ days: 30 }),\n      updatedAt: faker.date.recent({ days: 1 }),\n      completedAt: faker.date.recent({ days: 1 })\n    };\n\n    return { ...basePayment, ...overrides };\n  }\n\n  static createBatch(count: number, overrides: Partial<any> = {}) {\n    return Array.from({ length: count }, () => this.create(overrides));\n  }\n}\n\n/**\n * åœ°ç†æµ‹è¯•æ•°æ®å·¥å‚\n */\nexport class GeoFactory {\n  // åˆ›å»ºåœ°ç†å›´æ æµ‹è¯•æ•°æ®\n  static createGeofence(center?: { lat: number; lng: number }, radius: number = 1000) {\n    const fenceCenter = center || testUtils.generateBeijingCoordinate();\n    \n    return {\n      id: faker.string.uuid(),\n      name: faker.location.city() + 'å›´æ åŒºåŸŸ',\n      center: fenceCenter,\n      radius,\n      type: faker.helpers.arrayElement(['circle', 'polygon']),\n      isActive: faker.datatype.boolean({ probability: 0.8 }),\n      createdAt: faker.date.recent({ days: 30 })\n    };\n  }\n\n  // åˆ›å»ºè·¯å¾„è½¨è¿¹æ•°æ®\n  static createTrajectory(startPoint?: { lat: number; lng: number }, pointsCount: number = 10) {\n    const start = startPoint || testUtils.generateBeijingCoordinate();\n    const points = [start];\n\n    for (let i = 1; i < pointsCount; i++) {\n      const lastPoint = points[i - 1];\n      // æ¯æ¬¡ç§»åŠ¨ 50-200 ç±³\n      const nextPoint = {\n        lat: lastPoint.lat + faker.number.float({ min: -0.002, max: 0.002 }),\n        lng: lastPoint.lng + faker.number.float({ min: -0.002, max: 0.002 }),\n        timestamp: new Date(Date.now() + i * 60000), // æ¯åˆ†é’Ÿä¸€ä¸ªç‚¹\n        speed: faker.number.float({ min: 1, max: 15 }), // km/h\n        accuracy: faker.number.int({ min: 5, max: 20 }) // ç±³\n      };\n      points.push(nextPoint);\n    }\n\n    return {\n      id: faker.string.uuid(),\n      userId: faker.string.uuid(),\n      points,\n      totalDistance: calculateTrajectoryDistance(points),\n      duration: pointsCount * 60, // ç§’\n      createdAt: faker.date.recent({ days: 1 })\n    };\n  }\n\n  // åˆ›å»º PostGIS æŸ¥è¯¢æµ‹è¯•æ•°æ®\n  static createSpatialQuery() {\n    const queryTypes = ['nearest', 'within', 'intersects', 'contains'];\n    const center = testUtils.generateBeijingCoordinate();\n    \n    return {\n      type: faker.helpers.arrayElement(queryTypes),\n      center,\n      radius: faker.number.int({ min: 500, max: 5000 }),\n      bbox: {\n        north: center.lat + 0.01,\n        south: center.lat - 0.01,\n        east: center.lng + 0.01,\n        west: center.lng - 0.01\n      },\n      expectedResultCount: faker.number.int({ min: 0, max: 50 })\n    };\n  }\n}\n\n// è¾…åŠ©å‡½æ•°\nfunction generateGeoHash(lat: number, lng: number): string {\n  // ç®€åŒ–çš„ geohash ç”Ÿæˆï¼ˆå®é™…åº”ä½¿ç”¨ä¸“ä¸šåº“ï¼‰\n  return faker.string.alphanumeric(12);\n}\n\nfunction calculateDistanceFromCenter(location: { lat: number; lng: number }): number {\n  // ä»¥å¤©å®‰é—¨ä¸ºä¸­å¿ƒç‚¹\n  const CENTER = { lat: 39.9042, lng: 116.4074 };\n  return calculateDistance(location, CENTER);\n}\n\nfunction calculateDistance(p1: { lat: number; lng: number }, p2: { lat: number; lng: number }): number {\n  const R = 6371000; // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰\n  const Ï†1 = (p1.lat * Math.PI) / 180;\n  const Ï†2 = (p2.lat * Math.PI) / 180;\n  const Î”Ï† = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const Î”Î» = ((p2.lng - p1.lng) * Math.PI) / 180;\n\n  const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +\n    Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return R * c;\n}\n\nfunction calculateTrajectoryDistance(points: any[]): number {\n  let totalDistance = 0;\n  for (let i = 1; i < points.length; i++) {\n    totalDistance += calculateDistance(points[i - 1], points[i]);\n  }\n  return totalDistance;\n}\n\n// æ‰¹é‡æ•°æ®ç”Ÿæˆå™¨\nexport class DataGenerator {\n  static async seedTestDatabase() {\n    console.log('ğŸŒ± å¼€å§‹ç”Ÿæˆæµ‹è¯•æ•°æ®...');\n    \n    const users = UserFactory.createBatch(100);\n    const annotations = AnnotationFactory.createBatch(500);\n    const payments = PaymentFactory.createBatch(200);\n    \n    // è¿™é‡Œåº”è¯¥æ’å…¥åˆ°æ•°æ®åº“ä¸­\n    // å…·ä½“å®ç°æ ¹æ®ä½ çš„æ•°æ®åº“å±‚è€Œå®š\n    \n    console.log(`âœ… ç”Ÿæˆå®Œæˆ: ${users.length} ç”¨æˆ·, ${annotations.length} æ ‡æ³¨, ${payments.length} æ”¯ä»˜è®°å½•`);\n    \n    return { users, annotations, payments };\n  }\n\n  static createRealisticScenario() {\n    // åˆ›å»ºä¸€ä¸ªçœŸå®çš„ä¸šåŠ¡åœºæ™¯\n    const scenario = {\n      name: 'å·¥ä¸šå›­åŒºæ±¡æŸ“äº‹ä»¶',\n      location: BEIJING_HOTSPOTS.find(h => h.category === 'industrial')!,\n      users: [\n        UserFactory.createByType('NewUser'),\n        ...UserFactory.createBatch(3, { userType: 'ActiveUser' }),\n        UserFactory.createByType('PowerUser')\n      ],\n      annotations: [],\n      timespan: {\n        start: faker.date.recent({ days: 7 }),\n        end: faker.date.recent({ days: 1 })\n      }\n    };\n\n    // åœ¨è¯¥ä½ç½®é™„è¿‘åˆ›å»ºå¤šä¸ªç›¸å…³æ ‡æ³¨\n    scenario.annotations = AnnotationFactory.createForHotspot(scenario.location.name, 10)\n      .map(annotation => ({\n        ...annotation,\n        category: 'industrial',\n        intensity: faker.number.int({ min: 6, max: 10 }),\n        createdAt: faker.date.between({ \n          from: scenario.timespan.start, \n          to: scenario.timespan.end \n        })\n      }));\n\n    return scenario;\n  }\n}\n\n// é‡ç½®éšæœºç§å­çš„å·¥å…·å‡½æ•°\nexport function resetSeed(seed: number = 42) {\n  faker.seed(seed);\n  console.log(`ğŸ² é‡ç½®éšæœºç§å­ä¸º: ${seed}`);\n}\n\n// å¯¼å‡ºçƒ­åŒºæ•°æ®ä¾›æµ‹è¯•ä½¿ç”¨\nexport { BEIJING_HOTSPOTS, SMELL_CATEGORIES, USER_PATTERNS };