"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserJourneyRunner = void 0;
const test_1 = require("@playwright/test");
const ux_metrics_1 = require("./utils/ux-metrics");
const auth_page_1 = require("./page-objects/auth-page");
const map_page_1 = require("./page-objects/map-page");
const test_data_1 = require("./fixtures/test-data");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
class UserJourneyRunner {
    constructor() {
        this.browser = null;
        this.results = [];
        this.startTime = 0;
    }
    async initialize() {
        console.log('üöÄ ÂàùÂßãÂåñÁî®Êà∑Ë∑ØÂæÑÊµãËØïËøêË°åÂô®...');
        this.browser = await test_1.chromium.launch({
            headless: process.env.HEADLESS !== 'false',
            slowMo: process.env.SLOW_MO ? parseInt(process.env.SLOW_MO) : 0
        });
        this.startTime = Date.now();
    }
    async cleanup() {
        if (this.browser) {
            await this.browser.close();
        }
    }
    async runNewUserRegistrationTests() {
        console.log('üìù ÂºÄÂßãÊñ∞Áî®Êà∑Ê≥®ÂÜåÊµÅÁ®ãÊµãËØï...');
        const results = [];
        const devices = [
            { name: 'Desktop Chrome', device: null },
            { name: 'Mobile Safari', device: devices['iPhone 12'] },
            { name: 'Tablet iPad', device: devices['iPad Pro'] }
        ];
        for (const deviceConfig of devices) {
            const result = await this.runSingleTest(`Êñ∞Áî®Êà∑Ê≥®ÂÜå - ${deviceConfig.name}`, async (context, uxCollector) => {
                const page = await context.newPage();
                const authPage = new auth_page_1.AuthPage(page);
                await uxCollector.measurePageLoadTime();
                uxCollector.startTask('registration');
                const userData = test_data_1.TestData.users.newUser;
                await authPage.navigateToRegister();
                await authPage.register({
                    username: `${userData.username}_${Date.now()}`,
                    email: `test_${Date.now()}@example.com`,
                    password: userData.password
                });
                if (page.url().includes('/verify')) {
                    await authPage.verifyEmail('123456');
                }
                await authPage.verifyLoggedIn();
                const registrationTime = uxCollector.endTask('registration');
                await uxCollector.collectWebVitals();
                return {
                    success: true,
                    metrics: { registrationTime },
                    feedback: await this.simulateUserFeedback('registration', registrationTime)
                };
            }, deviceConfig.device);
            results.push(result);
        }
        return results;
    }
    async runAnnotationCreatorTests() {
        console.log('üè∑Ô∏è ÂºÄÂßãÊ†áÊ≥®ÂàõÂª∫ËÄÖÊµÅÁ®ãÊµãËØï...');
        const results = [];
        const result = await this.runSingleTest('Ê†áÊ≥®ÂàõÂª∫ËÄÖÂÆåÊï¥ÊµÅÁ®ã', async (context, uxCollector) => {
            const page = await context.newPage();
            const authPage = new auth_page_1.AuthPage(page);
            const mapPage = new map_page_1.MapPage(page);
            const userData = await authPage.createAndLoginTestUser();
            uxCollector.startTask('annotationCreation');
            await mapPage.navigateToMap();
            await mapPage.waitForMapLoad();
            const annotation = test_data_1.TestData.annotations.pleasant[0];
            await mapPage.createAnnotation({
                ...annotation,
                latitude: 40.7128,
                longitude: -74.0060
            });
            const creationTime = uxCollector.endTask('annotationCreation');
            await mapPage.verifyAnnotationCount(1);
            return {
                success: true,
                metrics: { creationTime },
                feedback: await this.simulateUserFeedback('creation', creationTime)
            };
        });
        results.push(result);
        return results;
    }
    async runRewardDiscovererTests() {
        console.log('üéÅ ÂºÄÂßãÂ•ñÂä±ÂèëÁé∞ËÄÖÊµÅÁ®ãÊµãËØï...');
        const results = [];
        const result = await this.runSingleTest('Â•ñÂä±ÂèëÁé∞ËÄÖÂÆåÊï¥ÊµÅÁ®ã', async (context, uxCollector) => {
            const page = await context.newPage();
            const authPage = new auth_page_1.AuthPage(page);
            const mapPage = new map_page_1.MapPage(page);
            const userData = test_data_1.TestData.users.rewardDiscoverer;
            await authPage.login(`${userData.email}_${Date.now()}@test.com`, userData.password);
            uxCollector.startTask('rewardDiscovery');
            await mapPage.navigateToMap();
            await mapPage.waitForMapLoad();
            await mapPage.getCurrentLocation();
            await mapPage.enterGeofence(40.7589, -73.9851);
            await mapPage.claimReward();
            const discoveryTime = uxCollector.endTask('rewardDiscovery');
            return {
                success: true,
                metrics: { discoveryTime },
                feedback: await this.simulateUserFeedback('discovery', discoveryTime)
            };
        });
        results.push(result);
        return results;
    }
    async runSocialInteractionTests() {
        console.log('üë• ÂºÄÂßãÁ§æ‰∫§‰∫íÂä®ÊµÅÁ®ãÊµãËØï...');
        const results = [];
        const result = await this.runSingleTest('Á§æ‰∫§‰∫íÂä®ÂÆåÊï¥ÊµÅÁ®ã', async (context, uxCollector) => {
            const page = await context.newPage();
            const authPage = new auth_page_1.AuthPage(page);
            const mapPage = new map_page_1.MapPage(page);
            const userData = test_data_1.TestData.users.socialUser;
            await authPage.login(`${userData.email}_${Date.now()}@test.com`, userData.password);
            uxCollector.startTask('socialInteraction');
            await mapPage.navigateToMap();
            await mapPage.waitForMapLoad();
            await mapPage.clickAnnotationMarker(0);
            await mapPage.likeAnnotation();
            const interactionTime = uxCollector.endTask('socialInteraction');
            return {
                success: true,
                metrics: { interactionTime },
                feedback: await this.simulateUserFeedback('social', interactionTime)
            };
        });
        results.push(result);
        return results;
    }
    async runCrossDeviceNetworkTests() {
        console.log('üì± ÂºÄÂßãË∑®ËÆæÂ§áÂíåÁΩëÁªúÁéØÂ¢ÉÊµãËØï...');
        const results = [];
        const networkConditions = [
            { name: 'Âø´ÈÄüÁΩëÁªú', delay: 0 },
            { name: 'ÊÖ¢ÈÄü3G', delay: 2000 },
            { name: '‰∏çÁ®≥ÂÆöÁΩëÁªú', delay: 'random' }
        ];
        for (const network of networkConditions) {
            const result = await this.runSingleTest(`ÁΩëÁªúÊµãËØï - ${network.name}`, async (context, uxCollector) => {
                if (network.delay !== 0) {
                    await context.route('**/*', async (route) => {
                        const delay = network.delay === 'random'
                            ? Math.random() * 3000
                            : network.delay;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        await route.continue();
                    });
                }
                const page = await context.newPage();
                const authPage = new auth_page_1.AuthPage(page);
                const mapPage = new map_page_1.MapPage(page);
                uxCollector.startTask('networkTest');
                const userData = await authPage.createAndLoginTestUser();
                await mapPage.navigateToMap();
                await mapPage.waitForMapLoad();
                const networkTestTime = uxCollector.endTask('networkTest');
                return {
                    success: true,
                    metrics: { networkTestTime },
                    feedback: await this.simulateUserFeedback('network', networkTestTime)
                };
            });
            results.push(result);
        }
        return results;
    }
    async runSingleTest(testName, testFunction, device) {
        console.log(`‚ñ∂Ô∏è  ËøêË°åÊµãËØï: ${testName}`);
        const startTime = Date.now();
        const screenshots = [];
        try {
            const contextOptions = device ? { ...device } : {};
            contextOptions.permissions = ['geolocation', 'notifications'];
            contextOptions.geolocation = { latitude: 40.7128, longitude: -74.0060 };
            const context = await this.browser.newContext(contextOptions);
            const page = await context.newPage();
            const uxCollector = new ux_metrics_1.UXMetricsCollector(page);
            const screenshotDir = path_1.default.join('test-results', 'screenshots', testName.replace(/\s+/g, '-'));
            if (!fs_1.default.existsSync(screenshotDir)) {
                fs_1.default.mkdirSync(screenshotDir, { recursive: true });
            }
            const result = await testFunction(context, uxCollector);
            const uxMetrics = await uxCollector.generateUXReport();
            await uxCollector.exportMetrics(`${testName.replace(/\s+/g, '-')}.json`);
            const finalScreenshot = path_1.default.join(screenshotDir, 'final.png');
            await page.screenshot({ path: finalScreenshot, fullPage: true });
            screenshots.push(finalScreenshot);
            await context.close();
            const duration = Date.now() - startTime;
            console.log(`‚úÖ ${testName} ÂÆåÊàê (${duration}ms)`);
            return {
                testName,
                status: 'passed',
                duration,
                screenshots,
                uxMetrics,
                userFeedback: result.feedback
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            console.error(`‚ùå ${testName} Â§±Ë¥• (${duration}ms):`, error);
            return {
                testName,
                status: 'failed',
                duration,
                error: error.message,
                screenshots
            };
        }
    }
    async simulateUserFeedback(taskType, duration) {
        let satisfactionScore = 10;
        const usabilityIssues = [];
        const suggestions = [];
        if (duration > 30000) {
            satisfactionScore -= 2;
            usabilityIssues.push('‰ªªÂä°ÂÆåÊàêÊó∂Èó¥ËøáÈïø');
            suggestions.push('‰ºòÂåñÈ°µÈù¢Âä†ËΩΩÈÄüÂ∫¶');
        }
        if (duration > 60000) {
            satisfactionScore -= 2;
            usabilityIssues.push('Áî®Êà∑ÊµÅÁ®ãÂ§çÊùÇ');
            suggestions.push('ÁÆÄÂåñÁî®Êà∑Êìç‰ΩúÊ≠•È™§');
        }
        switch (taskType) {
            case 'registration':
                if (duration > 15000) {
                    usabilityIssues.push('Ê≥®ÂÜåÊµÅÁ®ãÊ≠•È™§ËøáÂ§ö');
                    suggestions.push('ËÄÉËôëÁ§æ‰∫§Â™í‰ΩìÂø´ÈÄüÁôªÂΩï');
                }
                break;
            case 'creation':
                if (duration > 45000) {
                    usabilityIssues.push('Ê†áÊ≥®ÂàõÂª∫ÁïåÈù¢‰∏çÂ§üÁõ¥ËßÇ');
                    suggestions.push('Â¢ûÂä†Êõ¥Ê∏ÖÊô∞ÁöÑËßÜËßâÂºïÂØº');
                }
                break;
            case 'discovery':
                suggestions.push('Â•ñÂä±ÂèëÁé∞‰ΩìÈ™åÂæàÂ•Ω');
                break;
            case 'social':
                suggestions.push('Á§æ‰∫§ÂäüËÉΩËÆæËÆ°ËâØÂ•Ω');
                break;
        }
        return {
            taskCompletionRate: duration < 60000 ? 1.0 : 0.8,
            userSatisfactionScore: Math.max(1, Math.min(10, satisfactionScore)),
            usabilityIssues,
            suggestions
        };
    }
    async generateComprehensiveReport() {
        const totalDuration = Date.now() - this.startTime;
        const passed = this.results.filter(r => r.status === 'passed').length;
        const failed = this.results.filter(r => r.status === 'failed').length;
        const skipped = this.results.filter(r => r.status === 'skipped').length;
        const pageLoadTimes = this.results
            .map(r => r.uxMetrics?.pageLoadTime || 0)
            .filter(time => time > 0);
        const averagePageLoadTime = pageLoadTimes.length > 0
            ? pageLoadTimes.reduce((a, b) => a + b, 0) / pageLoadTimes.length
            : 0;
        const allIssues = this.results
            .flatMap(r => r.userFeedback?.usabilityIssues || []);
        const allSuggestions = this.results
            .flatMap(r => r.userFeedback?.suggestions || []);
        const criticalIssues = allIssues.filter(issue => issue.includes('Êó∂Èó¥ËøáÈïø') || issue.includes('Â§±Ë¥•'));
        const moderateIssues = allIssues.filter(issue => issue.includes('Â§çÊùÇ') || issue.includes('‰∏çÂ§üÁõ¥ËßÇ'));
        const minorIssues = allIssues.filter(issue => !criticalIssues.includes(issue) && !moderateIssues.includes(issue));
        const positiveFindings = allSuggestions.filter(suggestion => suggestion.includes('ÂæàÂ•Ω') || suggestion.includes('ËâØÂ•Ω'));
        const recommendations = [
            ...new Set([
                ...allSuggestions.filter(s => !positiveFindings.includes(s)),
                criticalIssues.length > 0 ? '‰ºòÂÖàËß£ÂÜ≥ÂÖ≥ÈîÆÊÄßËÉΩÈóÆÈ¢ò' : '',
                averagePageLoadTime > 3000 ? '‰ºòÂåñÈ°µÈù¢Âä†ËΩΩÊÄßËÉΩ' : '',
                failed > 0 ? '‰øÆÂ§çÊµãËØïÂ§±Ë¥•ÁöÑÂäüËÉΩ' : ''
            ])
        ].filter(r => r !== '');
        const report = {
            summary: {
                totalTests: this.results.length,
                passed,
                failed,
                skipped,
                totalDuration,
                overallSuccessRate: this.results.length > 0 ? passed / this.results.length : 0
            },
            deviceResults: this.groupResultsByCategory('device'),
            networkResults: this.groupResultsByCategory('network'),
            userJourneyResults: this.groupResultsByCategory('journey'),
            performanceMetrics: {
                averagePageLoadTime,
                averageTaskCompletionTime: this.results
                    .map(r => r.duration)
                    .reduce((a, b) => a + b, 0) / this.results.length,
                errorRate: failed / this.results.length,
                conversionRates: this.calculateConversionRates()
            },
            usabilityFindings: {
                criticalIssues,
                moderateIssues,
                minorIssues,
                positiveFindings
            },
            recommendations,
            timestamp: new Date().toISOString()
        };
        return report;
    }
    groupResultsByCategory(category) {
        const grouped = {};
        this.results.forEach(result => {
            let key = 'other';
            if (category === 'device') {
                if (result.testName.includes('Mobile'))
                    key = 'mobile';
                else if (result.testName.includes('Tablet'))
                    key = 'tablet';
                else if (result.testName.includes('Desktop'))
                    key = 'desktop';
            }
            else if (category === 'network') {
                if (result.testName.includes('ÁΩëÁªú'))
                    key = 'network';
            }
            else if (category === 'journey') {
                if (result.testName.includes('Ê≥®ÂÜå'))
                    key = 'registration';
                else if (result.testName.includes('Ê†áÊ≥®'))
                    key = 'annotation';
                else if (result.testName.includes('Â•ñÂä±'))
                    key = 'reward';
                else if (result.testName.includes('Á§æ‰∫§'))
                    key = 'social';
            }
            if (!grouped[key])
                grouped[key] = [];
            grouped[key].push(result);
        });
        return grouped;
    }
    calculateConversionRates() {
        const registrationTests = this.results.filter(r => r.testName.includes('Ê≥®ÂÜå') && r.status === 'passed');
        const creationTests = this.results.filter(r => r.testName.includes('Ê†áÊ≥®') && r.status === 'passed');
        const discoveryTests = this.results.filter(r => r.testName.includes('Â•ñÂä±') && r.status === 'passed');
        return {
            registration: registrationTests.length / Math.max(1, this.results.filter(r => r.testName.includes('Ê≥®ÂÜå')).length),
            creation: creationTests.length / Math.max(1, this.results.filter(r => r.testName.includes('Ê†áÊ≥®')).length),
            discovery: discoveryTests.length / Math.max(1, this.results.filter(r => r.testName.includes('Â•ñÂä±')).length)
        };
    }
    async exportReport(report, filename = 'user-journey-report.json') {
        const reportPath = path_1.default.join('test-results', filename);
        const dir = path_1.default.dirname(reportPath);
        if (!fs_1.default.existsSync(dir)) {
            fs_1.default.mkdirSync(dir, { recursive: true });
        }
        fs_1.default.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        const htmlReport = this.generateHTMLReport(report);
        const htmlPath = reportPath.replace('.json', '.html');
        fs_1.default.writeFileSync(htmlPath, htmlReport);
        console.log(`üìä ÊµãËØïÊä•ÂëäÂ∑≤ÁîüÊàê:`);
        console.log(`   JSON: ${reportPath}`);
        console.log(`   HTML: ${htmlPath}`);
    }
    generateHTMLReport(report) {
        return `
<!DOCTYPE html>
<html>
<head>
    <title>SmellPin Áî®Êà∑Ë∑ØÂæÑÊµãËØïÊä•Âëä</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #e1e5e9; padding-bottom: 20px; margin-bottom: 30px; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .metric { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }
        .metric h3 { margin: 0 0 10px 0; color: #495057; }
        .metric .value { font-size: 2em; font-weight: bold; color: #007bff; }
        .passed { color: #28a745; }
        .failed { color: #dc3545; }
        .section { margin-bottom: 40px; }
        .issue-list { background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px; }
        .suggestion-list { background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; padding: 15px; }
        .test-result { margin: 10px 0; padding: 10px; border-left: 4px solid #ddd; }
        .test-result.passed { border-color: #28a745; }
        .test-result.failed { border-color: #dc3545; }
    </style>
</head>
<body>
    <div class="header">
        <h1>SmellPin Áî®Êà∑Ë∑ØÂæÑÊµãËØïÊä•Âëä</h1>
        <p>ÁîüÊàêÊó∂Èó¥: ${new Date(report.timestamp).toLocaleString('zh-CN')}</p>
    </div>
    
    <div class="summary">
        <div class="metric">
            <h3>ÊÄªÊµãËØïÊï∞</h3>
            <div class="value">${report.summary.totalTests}</div>
        </div>
        <div class="metric">
            <h3>ÈÄöËøá</h3>
            <div class="value passed">${report.summary.passed}</div>
        </div>
        <div class="metric">
            <h3>Â§±Ë¥•</h3>
            <div class="value failed">${report.summary.failed}</div>
        </div>
        <div class="metric">
            <h3>ÊàêÂäüÁéá</h3>
            <div class="value">${(report.summary.overallSuccessRate * 100).toFixed(1)}%</div>
        </div>
        <div class="metric">
            <h3>ÊÄªËÄóÊó∂</h3>
            <div class="value">${Math.round(report.summary.totalDuration / 1000)}s</div>
        </div>
    </div>
    
    <div class="section">
        <h2>ÊÄßËÉΩÊåáÊ†á</h2>
        <div class="summary">
            <div class="metric">
                <h3>Âπ≥ÂùáÈ°µÈù¢Âä†ËΩΩ</h3>
                <div class="value">${Math.round(report.performanceMetrics.averagePageLoadTime)}ms</div>
            </div>
            <div class="metric">
                <h3>Âπ≥Âùá‰ªªÂä°ÂÆåÊàê</h3>
                <div class="value">${Math.round(report.performanceMetrics.averageTaskCompletionTime / 1000)}s</div>
            </div>
            <div class="metric">
                <h3>ÈîôËØØÁéá</h3>
                <div class="value">${(report.performanceMetrics.errorRate * 100).toFixed(1)}%</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h2>ÂÖ≥ÈîÆÈóÆÈ¢ò</h2>
        <div class="issue-list">
            ${report.usabilityFindings.criticalIssues.length > 0
            ? report.usabilityFindings.criticalIssues.map(issue => `<li>${issue}</li>`).join('')
            : '<p>Êú™ÂèëÁé∞ÂÖ≥ÈîÆÈóÆÈ¢ò ‚úÖ</p>'}
        </div>
    </div>
    
    <div class="section">
        <h2>ÊîπËøõÂª∫ËÆÆ</h2>
        <div class="suggestion-list">
            ${report.recommendations.length > 0
            ? report.recommendations.map(rec => `<li>${rec}</li>`).join('')
            : '<p>ÂΩìÂâçË°®Áé∞ËâØÂ•ΩÔºåÊó†ÁâπÂà´Âª∫ËÆÆ üëç</p>'}
        </div>
    </div>
    
    <div class="section">
        <h2>ÁßØÊûÅÂèëÁé∞</h2>
        <div class="suggestion-list">
            ${report.usabilityFindings.positiveFindings.map(finding => `<li>${finding}</li>`).join('')}
        </div>
    </div>
</body>
</html>
    `;
    }
    async runCompleteTestSuite() {
        try {
            await this.initialize();
            console.log('üéØ ÂºÄÂßãÊâßË°åSmellPinÂÆåÊï¥Áî®Êà∑Ë∑ØÂæÑÊµãËØïÂ•ó‰ª∂\n');
            this.results.push(...await this.runNewUserRegistrationTests());
            this.results.push(...await this.runAnnotationCreatorTests());
            this.results.push(...await this.runRewardDiscovererTests());
            this.results.push(...await this.runSocialInteractionTests());
            this.results.push(...await this.runCrossDeviceNetworkTests());
            const report = await this.generateComprehensiveReport();
            await this.exportReport(report);
            console.log('\nüìä ÊµãËØïÂÆåÊàêÊÄªÁªì:');
            console.log(`‚úÖ ÈÄöËøá: ${report.summary.passed}`);
            console.log(`‚ùå Â§±Ë¥•: ${report.summary.failed}`);
            console.log(`üìà ÊàêÂäüÁéá: ${(report.summary.overallSuccessRate * 100).toFixed(1)}%`);
            console.log(`‚è±Ô∏è  ÊÄªËÄóÊó∂: ${Math.round(report.summary.totalDuration / 1000)}Áßí`);
            if (report.recommendations.length > 0) {
                console.log('\nüí° ‰∏ªË¶ÅÊîπËøõÂª∫ËÆÆ:');
                report.recommendations.slice(0, 3).forEach((rec, i) => {
                    console.log(`   ${i + 1}. ${rec}`);
                });
            }
        }
        finally {
            await this.cleanup();
        }
    }
}
exports.UserJourneyRunner = UserJourneyRunner;
if (require.main === module) {
    const runner = new UserJourneyRunner();
    runner.runCompleteTestSuite().catch(console.error);
}
//# sourceMappingURL=user-journey-runner.js.map