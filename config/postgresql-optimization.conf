# PostgreSQL Configuration Optimization for SmellPin LBS Platform
# Optimized for geographic queries, high-concurrency operations, and real-time performance
# Target: <100ms query response times for all LBS operations
#
# Apply these settings to your PostgreSQL configuration:
# 1. Add to postgresql.conf
# 2. Reload configuration: SELECT pg_reload_conf();
# 3. Monitor performance with provided queries

# =============================================================================
# CONNECTION AND AUTHENTICATION
# =============================================================================

# Maximum number of concurrent connections
# Adjust based on your expected concurrent users and connection pooling
max_connections = 100

# Connection pooling optimization
superuser_reserved_connections = 3

# Authentication timeout (reduce for security)
authentication_timeout = 30s

# =============================================================================
# RESOURCE USAGE (MEMORY)
# =============================================================================

# Shared memory buffer pool
# Should be 25% of total RAM for dedicated database server
# For 4GB RAM server: 1GB, for 8GB: 2GB, for 16GB: 4GB
shared_buffers = 2GB

# Memory for each database session
# For geographic queries and complex joins
work_mem = 64MB

# Memory for maintenance operations (vacuum, create index, etc.)
maintenance_work_mem = 256MB

# Maximum stack depth (for complex PostGIS operations)
max_stack_depth = 8MB

# Dynamic shared memory
dynamic_shared_memory_type = posix

# =============================================================================
# RESOURCE USAGE (ASYNCHRONOUS BEHAVIOR)
# =============================================================================

# Background writer process optimization
bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0

# Checkpoint process optimization (critical for write performance)
checkpoint_timeout = 15min
checkpoint_completion_target = 0.9
checkpoint_warning = 30s

# Maximum WAL size before forced checkpoint
max_wal_size = 2GB
min_wal_size = 512MB

# =============================================================================
# WRITE AHEAD LOG (WAL)
# =============================================================================

# WAL writer optimization
wal_writer_delay = 200ms
wal_writer_flush_after = 1MB

# WAL buffer size (in memory before writing to disk)
wal_buffers = 16MB

# Synchronous commit behavior (balance between performance and durability)
# For high-performance LBS operations, consider 'off' with proper backup strategy
synchronous_commit = on

# WAL level (minimal for performance, replica if you need streaming replication)
wal_level = replica

# =============================================================================
# REPLICATION (if using read replicas for scaling)
# =============================================================================

# Maximum number of WAL sender processes
max_wal_senders = 3

# Maximum replication slots
max_replication_slots = 3

# Hot standby settings
hot_standby = on
hot_standby_feedback = on

# =============================================================================
# QUERY TUNING
# =============================================================================

# Cost-based optimizer settings (tuned for SSD storage)
random_page_cost = 1.1        # Lower for SSD (default 4.0 for HDD)
seq_page_cost = 1.0
cpu_tuple_cost = 0.01
cpu_index_tuple_cost = 0.005
cpu_operator_cost = 0.0025

# Planner settings for complex geographic queries
geqo = on
geqo_threshold = 12
from_collapse_limit = 12
join_collapse_limit = 12

# Enable various join types
enable_hashagg = on
enable_hashjoin = on
enable_indexscan = on
enable_indexonlyscan = on
enable_material = on
enable_mergejoin = on
enable_nestloop = on
enable_seqscan = on
enable_sort = on
enable_tidscan = on

# Constraint exclusion for partitioned tables
constraint_exclusion = partition

# Default statistics target (higher = better estimates, slower ANALYZE)
default_statistics_target = 150

# =============================================================================
# LOGGING AND MONITORING
# =============================================================================

# Logging configuration for performance monitoring
log_destination = 'stderr'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_truncate_on_rotation = on
log_rotation_age = 1d
log_rotation_size = 100MB

# Log slow queries (critical for SmellPin LBS optimization)
log_min_duration_statement = 100ms    # Log queries slower than 100ms
log_statement = 'ddl'                 # Log DDL statements
log_duration = off
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# Log lock waits (important for high-concurrency scenarios)
log_lock_waits = on
deadlock_timeout = 1s

# Log checkpoint activity
log_checkpoints = on

# Log autovacuum activity
log_autovacuum_min_duration = 250ms

# =============================================================================
# AUTOVACUUM PARAMETERS
# =============================================================================

# Enable autovacuum (critical for maintaining performance)
autovacuum = on

# Autovacuum worker processes
autovacuum_max_workers = 4

# Autovacuum thresholds (aggressive settings for high-write workload)
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_threshold = 25
autovacuum_analyze_scale_factor = 0.05

# Autovacuum cost-based delay (balance between performance and resource usage)
autovacuum_naptime = 30s
autovacuum_vacuum_cost_delay = 10ms
autovacuum_vacuum_cost_limit = 1000

# =============================================================================
# CLIENT CONNECTION DEFAULTS
# =============================================================================

# Default transaction isolation level
default_transaction_isolation = 'read committed'

# Timezone
timezone = 'UTC'

# Default text search configuration
default_text_search_config = 'pg_catalog.english'

# Statement timeout (prevent runaway queries)
statement_timeout = 30s

# Lock timeout
lock_timeout = 5s

# Idle in transaction timeout (prevent long-running idle transactions)
idle_in_transaction_session_timeout = 60s

# =============================================================================
# POSTGIS SPECIFIC OPTIMIZATIONS
# =============================================================================

# These settings are specifically for PostGIS geographic operations

# Increase the maximum number of dimensions (if using complex geometries)
# max_pred_locks_per_transaction = 128

# Shared preload libraries (add PostGIS and other extensions)
shared_preload_libraries = 'pg_stat_statements,auto_explain'

# Auto explain settings for complex queries
auto_explain.log_min_duration = 500ms
auto_explain.log_analyze = on
auto_explain.log_buffers = on
auto_explain.log_timing = on
auto_explain.log_triggers = on
auto_explain.log_verbose = on
auto_explain.log_nested_statements = on

# pg_stat_statements settings for query analysis
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on
pg_stat_statements.save = on

# =============================================================================
# PERFORMANCE TUNING FOR HIGH CONCURRENCY LBS WORKLOADS
# =============================================================================

# Increase limits for high-concurrency scenarios
max_pred_locks_per_transaction = 128
max_pred_locks_per_relation = 32
max_pred_locks_per_page = 8

# Increase wal sender timeout for replication lag
wal_sender_timeout = 60s

# Optimize for mixed read/write workload
effective_cache_size = 6GB    # Should be 75% of total RAM

# Parallel query settings (PostgreSQL 9.6+)
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
parallel_tuple_cost = 0.1
parallel_setup_cost = 1000.0

# =============================================================================
# SMELLPIN SPECIFIC TABLE OPTIMIZATIONS
# =============================================================================

# These settings can be applied to specific tables for better performance
# Use ALTER TABLE commands:

# -- For high-write tables like location_reports
# ALTER TABLE location_reports SET (
#   autovacuum_vacuum_scale_factor = 0.05,
#   autovacuum_analyze_scale_factor = 0.02,
#   autovacuum_vacuum_cost_limit = 2000
# );

# -- For spatial tables with heavy geographic queries
# ALTER TABLE annotations SET (
#   autovacuum_vacuum_scale_factor = 0.1,
#   autovacuum_analyze_scale_factor = 0.05,
#   random_page_cost = 1.0
# );

# -- For read-heavy tables like users
# ALTER TABLE users SET (
#   autovacuum_vacuum_scale_factor = 0.2,
#   autovacuum_analyze_scale_factor = 0.1
# );

# =============================================================================
# MONITORING QUERIES
# =============================================================================

# Use these queries to monitor PostgreSQL performance:

# -- Check buffer hit ratio (should be >95%)
# SELECT 
#   sum(heap_blks_read) as heap_read,
#   sum(heap_blks_hit) as heap_hit,
#   round(sum(heap_blks_hit)::numeric / (sum(heap_blks_hit) + sum(heap_blks_read)) * 100, 2) as hit_ratio
# FROM pg_statio_user_tables;

# -- Check index usage
# SELECT 
#   schemaname,
#   tablename,
#   indexname,
#   idx_scan,
#   idx_tup_read,
#   idx_tup_fetch
# FROM pg_stat_user_indexes
# ORDER BY idx_scan DESC;

# -- Check slow queries
# SELECT 
#   query,
#   calls,
#   total_time,
#   mean_time,
#   rows
# FROM pg_stat_statements
# ORDER BY mean_time DESC
# LIMIT 20;

# -- Check table bloat
# SELECT 
#   tablename,
#   n_live_tup,
#   n_dead_tup,
#   round(n_dead_tup::numeric / (n_live_tup + n_dead_tup) * 100, 2) as bloat_ratio
# FROM pg_stat_user_tables
# WHERE n_live_tup + n_dead_tup > 0
# ORDER BY bloat_ratio DESC;

# -- Check connection usage
# SELECT 
#   count(*) as total_connections,
#   count(*) FILTER (WHERE state = 'active') as active,
#   count(*) FILTER (WHERE state = 'idle') as idle,
#   count(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction
# FROM pg_stat_activity;

# -- Check autovacuum activity
# SELECT 
#   schemaname,
#   tablename,
#   last_vacuum,
#   last_autovacuum,
#   last_analyze,
#   last_autoanalyze,
#   n_dead_tup,
#   n_live_tup
# FROM pg_stat_user_tables
# ORDER BY last_autovacuum DESC NULLS LAST;

# =============================================================================
# DEPLOYMENT CHECKLIST
# =============================================================================

# Before deploying these settings:
# 1. Backup your current postgresql.conf
# 2. Test in staging environment first
# 3. Monitor key metrics after deployment:
#    - Buffer hit ratio
#    - Average query response time
#    - Connection pool utilization
#    - Disk I/O patterns
#    - Memory usage
# 4. Adjust settings based on actual workload patterns
# 5. Set up automated alerts for performance degradation

# =============================================================================
# SCALING RECOMMENDATIONS
# =============================================================================

# For scaling beyond single server:
# 1. Implement read replicas for read-heavy operations
# 2. Consider partitioning large tables (location_reports, annotations)
# 3. Use connection pooling (PgBouncer) at application level
# 4. Implement caching layer (Redis) for frequently accessed data
# 5. Monitor and optimize PostGIS spatial indexes regularly

# Remember: These settings are starting points. 
# Always test and adjust based on your specific workload and hardware.